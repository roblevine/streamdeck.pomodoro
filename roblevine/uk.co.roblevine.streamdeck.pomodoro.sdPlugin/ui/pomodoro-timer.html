<!DOCTYPE html>
<html>

<head lang="en">
    <title>Pomodoro Timer Settings</title>
    <meta charset="utf-8" />
    <script src="https://sdpi-components.dev/releases/v4/sdpi-components.js"></script>
    <style>
        .group-title {
            margin: 8px 0 4px;
            font-weight: 600;
            color: #dddddd;
            font-family: Segoe UI, Arial, sans-serif;
        }
        .group-divider {
            height: 1px;
            background: #333333;
            margin: 8px 0 10px;
        }
        .group-container { padding: 2px 0; }
    </style>
    <script>
        // Track playback state
        const playbackState = {
            work: false,
            break: false
        };

        // Hook into the connection callback to set up message handlers
        (function() {
            const script = document.createElement('script');
            script.textContent = `
                (function() {
                    const originalConnect = window.connectElgatoStreamDeckSocket;
                    window.connectElgatoStreamDeckSocket = function(inPort, inPluginUUID, inRegisterEvent, inInfo, inActionInfo) {
                        // Call sdpi-components' original handler first
                        if (originalConnect) {
                            originalConnect.apply(this, arguments);
                        }

                        // Set up our custom message handlers
                        setTimeout(() => {
                            if (window.setupMessageHandlers) {
                                window.setupMessageHandlers();
                            }
                        }, 100);
                    };
                })();
            `;
            document.head.appendChild(script);
        })();

        // Set up handlers for messages from the plugin
        window.setupMessageHandlers = function() {
            // Listen for messages from the plugin using the streamDeckClient's event system
            const { streamDeckClient } = window.SDPIComponents;

            // Subscribe to sendToPropertyInspector events
            streamDeckClient.sendToPropertyInspector.handlers.push((event) => {
                // Handle both direct event structure and wrapped payload structure
                const message = event.type ? event : (event.payload || event);
                
                if (message.type === 'playbackStarted') {
                    const playbackId = message.payload?.playbackId || message.playbackId;
                    console.log('[PI MessageBus] Playback started:', playbackId);
                    if (playbackId) {
                        updateButtonState(playbackId, true);
                    }
                } else if (message.type === 'playbackStopped') {
                    const playbackId = message.payload?.playbackId || message.playbackId;
                    console.log('[PI MessageBus] Playback stopped:', playbackId);
                    if (playbackId) {
                        updateButtonState(playbackId, false);
                    }
                }
            });

            // Set initial state for sound controls
            streamDeckClient.getSettings().then(settings => {
                const nested = settings?.settings ?? settings; // sdpi returns envelope with nested settings
                // Only treat explicit true/'true' as enabled. Default to disabled.
                const isEnabled = (nested.enableSound === true || nested.enableSound === 'true');
                updateSoundControlsState(isEnabled);

                // Also bind the checkbox inner input once settings are known
                try { initializeEnableSoundCheckbox(nested); } catch (e) {}
            });

            // Listen for settings changes via didReceiveSettings event
            streamDeckClient.didReceiveSettings.handlers.push((event) => {
                const settings = event.payload?.settings || event.settings || event;
                // Only treat explicit true/'true' as enabled. Default to disabled.
                const isEnabled = (settings.enableSound === true || settings.enableSound === 'true');
                updateSoundControlsState(isEnabled);
            });
        };

        // Monitor changes via sdpi-components event bus
        document.addEventListener('DOMContentLoaded', () => {
            const checkbox = document.querySelector('sdpi-checkbox[setting="enableSound"]');

            // sdpi-components emits a custom 'sdpi:change' event
            document.addEventListener('sdpi:change', (e) => {
                try {
                    const detail = e.detail || {};
                    const el = detail.control || detail.element || e.target;
                    const settingName = el?.getAttribute?.('setting');
                    if (settingName === 'enableSound') {
                        const raw = detail.value;
                        const checked = (raw === true || raw === 'true') || (!!el?.checked);
                        updateSoundControlsState(checked);
                        // Persist explicitly for reliability
                        try {
                            const { streamDeckClient } = window.SDPIComponents;
                            streamDeckClient.setSettings({ enableSound: checked });
                        } catch (err) {
                            
                        }
                    }
                } catch (err) {
                    
                }
            });

            // As a fallback, bind directly to the checkbox's shadow input
            setTimeout(() => { try { initializeEnableSoundCheckbox(); } catch (_) {} }, 200);
        });

        // Bind to the sdpi-checkbox's internal input to detect user interaction
        function initializeEnableSoundCheckbox(existingSettings) {
            const el = document.querySelector('sdpi-checkbox[setting="enableSound"]');
            if (!el) return;

            const applyInitial = (input) => {
                const raw = existingSettings?.enableSound;
                const shouldCheck = raw === true || raw === 'true';
                if (typeof shouldCheck === 'boolean') {
                    input.checked = shouldCheck;
                }
            };

            const bind = () => {
                const input = el.shadowRoot && el.shadowRoot.querySelector && el.shadowRoot.querySelector('input[type="checkbox"]');
                if (!input) {
                    // Not yet rendered; try again shortly
                    setTimeout(bind, 100);
                    return;
                }
                if (input.__enableSoundBound) return; // prevent double-binding
                input.__enableSoundBound = true;
                applyInitial(input);
                input.addEventListener('change', () => {
                    const checked = !!input.checked;
                    updateSoundControlsState(checked);
                    try {
                        const { streamDeckClient } = window.SDPIComponents;
                        streamDeckClient.setSettings({ enableSound: checked });
                    } catch (err) {
                        
                    }
                });
            };

            bind();
        }

        // Update enabled/disabled state of sound controls
        function updateSoundControlsState(enabled) {
            const workSoundFile = document.querySelector('#workSoundFile');
            const breakSoundFile = document.querySelector('#breakSoundFile');
            const workPreviewBtn = document.querySelector('#workPreviewBtn');
            const breakPreviewBtn = document.querySelector('#breakPreviewBtn');

            if (workSoundFile) {
                workSoundFile.disabled = !enabled;
                if (!enabled) workSoundFile.setAttribute('disabled', ''); else workSoundFile.removeAttribute('disabled');
            }
            if (breakSoundFile) {
                breakSoundFile.disabled = !enabled;
                if (!enabled) breakSoundFile.setAttribute('disabled', ''); else breakSoundFile.removeAttribute('disabled');
            }
            if (workPreviewBtn) {
                workPreviewBtn.disabled = !enabled;
                if (!enabled) workPreviewBtn.setAttribute('disabled', ''); else workPreviewBtn.removeAttribute('disabled');
            }
            if (breakPreviewBtn) {
                breakPreviewBtn.disabled = !enabled;
                if (!enabled) breakPreviewBtn.setAttribute('disabled', ''); else breakPreviewBtn.removeAttribute('disabled');
            }
        }

        // Update button state based on playback
        function updateButtonState(playbackId, isPlaying) {
            if (playbackId === 'work-preview') {
                playbackState.work = isPlaying;
                const button = document.querySelector('#workPreviewBtn');
                if (button) {
                    button.textContent = isPlaying ? 'Stop' : 'Preview';
                } else {
                    console.warn('[ButtonState] Work preview button not found');
                }
            } else if (playbackId === 'break-preview') {
                playbackState.break = isPlaying;
                const button = document.querySelector('#breakPreviewBtn');
                if (button) {
                    button.textContent = isPlaying ? 'Stop' : 'Preview';
                } else {
                    console.warn('[ButtonState] Break preview button not found');
                }
            } else {
                console.warn('[ButtonState] Unknown playbackId:', playbackId);
            }
        }
    </script>
</head>

<body>
    <sdpi-item label="Info">
        <span>
        Configure your Pomodoro timer settings here. Each cycle consists of a work period followed by a short break, a specified number of times. The final break is longer.
        Pressing the button while the timer is running will pause the timer. Pressing again will resume it.
        Double-press the button to skip to the next phase (if running, it stops and advances).
        Long-pressing the button for 2 seconds will reset the timer.
        </span>
    </sdpi-item>
    <!-- Timer Settings Group -->
    <div class="group-title">Timer Settings</div>
    <div class="group-container">    
        <sdpi-item label="Info">
            <span>
            Set your timer settings here, plus the number of cycles before a long break.
            </span>
        </sdpi-item>
        <sdpi-item label="Work Duration (mm:ss)">
            <sdpi-textfield setting="workDuration" type="text" pattern="\d{1,3}:\d{2}"></sdpi-textfield>
        </sdpi-item>
        <sdpi-item label="Short Break Duration (mm:ss)">
            <sdpi-textfield setting="shortBreakDuration" type="text" pattern="\d{1,3}:\d{2}"></sdpi-textfield>
        </sdpi-item>
        <sdpi-item label="Long Break Duration (mm:ss)">
            <sdpi-textfield setting="longBreakDuration" type="text" pattern="\d{1,3}:\d{2}"></sdpi-textfield>
        </sdpi-item>
        <sdpi-item label="Cycles Before Long Break">
            <sdpi-textfield setting="cyclesBeforeLongBreak" type="number" min="1" max="10"></sdpi-textfield>
        </sdpi-item>
        <sdpi-item label="Pause At End Of Each Phase">
            <sdpi-checkbox setting="pauseAtEndOfEachTimer" value="true"></sdpi-checkbox>
            <br/>When enabled, the next phase will wait for a press before starting; when off, phases auto-advance.
        </sdpi-item>
        <sdpi-item label="Completion Hold (seconds)">
            <sdpi-textfield setting="completionHoldSeconds" type="number" min="0" max="10"></sdpi-textfield>
            Time to pause at the end of a timer before proceeding to next step (or pausing further if "Pause At End Of Each Phase" is enabled)
        </sdpi-item>
    </div>

    <div class="group-divider"></div>

    <!-- Sound Settings Group -->
    <div class="group-title">Sound Settings</div>
    <div class="group-container">
        <sdpi-item label="Info">
            <span>
            Set your sound settings here. You can enable or disable sound for the timer.
            </span>
        </sdpi-item>
        <sdpi-item label="Enable Sound">
            <sdpi-checkbox setting="enableSound" value="true"></sdpi-checkbox>
        </sdpi-item>
        <sdpi-item label="Work End Sound (.wav)">
            <sdpi-file id="workSoundFile" setting="workEndSoundPath" accept=".wav" placeholder="Select work period end sound"></sdpi-file>
            <sdpi-button id="workPreviewBtn" onclick="previewWorkSound()">Preview</sdpi-button>
        </sdpi-item>
        <sdpi-item label="Break End Sound (.wav)">
            <sdpi-file id="breakSoundFile" setting="breakEndSoundPath" accept=".wav" placeholder="Select break end sound"></sdpi-file>
            <sdpi-button id="breakPreviewBtn" onclick="previewBreakSound()">Preview</sdpi-button>
        </sdpi-item>
    </div>

    <script>
        // Global functions for button clicks
        window.previewWorkSound = function() {
            const { streamDeckClient } = window.SDPIComponents;

            if (playbackState.work) {
                // Stop playback
                console.log('[Preview] Stopping work sound');
                updateButtonState('work-preview', false); // Optimistic update
                streamDeckClient.send('sendToPlugin', {
                    type: 'stopSound',
                    payload: { playbackId: 'work-preview' }
                });
            } else {
                // Start playback
                const fileInput = document.getElementById('workSoundFile');
                const filePath = fileInput?.value;

                if (filePath) {
                    console.log('[Preview] Starting work sound:', filePath);
                    updateButtonState('work-preview', true); // Optimistic update
                    streamDeckClient.send('sendToPlugin', {
                        type: 'previewSound',
                        payload: { filePath, playbackId: 'work-preview' }
                    });
                } else {
                    console.warn('[Preview] No file selected for work sound');
                }
            }
        };

        window.previewBreakSound = function() {
            const { streamDeckClient } = window.SDPIComponents;

            if (playbackState.break) {
                // Stop playback
                console.log('[Preview] Stopping break sound');
                updateButtonState('break-preview', false); // Optimistic update
                streamDeckClient.send('sendToPlugin', {
                    type: 'stopSound',
                    payload: { playbackId: 'break-preview' }
                });
            } else {
                // Start playback
                const fileInput = document.getElementById('breakSoundFile');
                const filePath = fileInput?.value;

                if (filePath) {
                    console.log('[Preview] Starting break sound:', filePath);
                    updateButtonState('break-preview', true); // Optimistic update
                    streamDeckClient.send('sendToPlugin', {
                        type: 'previewSound',
                        payload: { filePath, playbackId: 'break-preview' }
                    });
                } else {
                    console.warn('[Preview] No file selected for break sound');
                }
            }
        };
    </script>
</body>

</html>
